/* =========================================================
   INTERVIEW NOTE:
   This component is a playground demonstrating:
   - RxJS operators
   - Cold vs Hot observables
   - Subjects & multicasting
   - HTTP + cancellation
   - Memory management using takeUntil
========================================================= */

import {
  Component,
  ElementRef,
  inject,
  OnDestroy,
  OnInit,
  ViewChild,
} from '@angular/core';

import { RxjsandobservablesService, User } from './service/rxjsandobservables';
import { HttpClient } from '@angular/common/http';

import {
  catchError,
  combineLatest,
  concat,
  concatMap,
  debounceTime,
  delay,
  distinctUntilChanged,
  EMPTY,
  exhaustMap,
  filter,
  forkJoin,
  from,
  fromEvent,
  interval,
  map,
  merge,
  mergeMap,
  Observable,
  of,
  retry,
  shareReplay,
  Subject,
  switchMap,
  take,
  takeUntil,
  tap,
  throttleTime,
  timer,
} from 'rxjs';

import { CommonModule } from '@angular/common';
import { ajax } from 'rxjs/ajax';
import { FormControl, ReactiveFormsModule } from '@angular/forms';
import { AutocompleteService } from '../autocomplete-searchbar/service/autocomplete';
import { MatGridTile } from "@angular/material/grid-list";

/* =========================================================
   INTERFACES (INTERVIEW: Strong typing for API contracts)
========================================================= */

interface IApiUser {
  id: number;
  name: string;
  email: string;
  address: { street: string; city: string; zipcode: string };
  company: { name: string };
}

interface ITransformedUser {
  userId: number;
  userBio: string;
  location: string;
  employment: string;
}

@Component({
  selector: 'app-rxjsandobservables',
  imports: [CommonModule, ReactiveFormsModule, MatGridTile],
  templateUrl: './rxjsandobservables.html',
  styleUrl: './rxjsandobservables.scss',
})
export class Rxjsandobservables implements OnInit, OnDestroy {

  /* =========================================================
     INTERVIEW: ViewChild is used to access DOM safely
  ========================================================= */
  @ViewChild('showsInput', { static: true }) showsInput!: ElementRef;
  @ViewChild('showsInputText', { static: true }) showsInputText!: ElementRef;

  /* =========================================================
     INTERVIEW: Subject used to clean subscriptions
  ========================================================= */
  private destroy$ = new Subject<void>();

  /* =========================================================
     INTERVIEW: inject() is modern DI alternative
  ========================================================= */
  http = inject(HttpClient);
  apiService = inject(RxjsandobservablesService);

  /* =========================================================
     BASIC OBSERVABLE (Cold Observable Example)
  ========================================================= */
  myObservable = new Observable(observer => {
    observer.next('Hello');
    observer.next('World');
    observer.complete();
  });

  source$ = from([1, 2, 3, 4, 5]);
  source = from([1, 2, 3, 4, 5]);

  /* =========================================================
     INTERVIEW: tap → map → filter pipeline
  ========================================================= */
  doubled = this.source.pipe(
    tap(val => val),
    map(val => val * 1),
    filter(val => val % 2 !== 0),
    tap(val => val)
  );

  /* =========================================================
     FORM CONTROL (Reactive Forms + RxJS)
  ========================================================= */
  searchControl = new FormControl('');

  /* =========================================================
     INTERVIEW: shareReplay avoids duplicate API calls
  ========================================================= */
  users$ = this.apiService.getUsers().pipe(
    shareReplay({ bufferSize: 1, refCount: true })
  );

  constructor(private service: AutocompleteService) {

    // INTERVIEW: Demonstrates Subjects & multicasting
    this.apiService.subject.subscribe(res => console.log(res));
    this.apiService.newSubject.subscribe(res => console.log(res));
    this.apiService.behaviorSubject.subscribe(res => console.log(res));
    this.apiService.neBehSubject.subscribe(res => console.log(res));

    // INTERVIEW: valueChanges is preferred over (input)
    this.searchControl.valueChanges
      .pipe(
        debounceTime(500),
        distinctUntilChanged(),
        throttleTime(2000)
      )
      .subscribe(res => console.log(res));
  }

  /* =========================================================
     LIFECYCLE INIT
  ========================================================= */
  ngOnInit(): void {

    this.emitSubjectValues();
    this.setupTvMazeSearch();
    this.setupArtInstituteSearch();
    this.basicFromEventExamples();
    this.basicRxjsExamples();
    this.intervalExamples();
    this.combineLatestExample();
  }

  /* =========================================================
     INTERVIEW: Emits values into Subjects after delay
  ========================================================= */
  private emitSubjectValues() {
    setTimeout(() => {
      this.apiService.subject.next('hello');
      this.apiService.newSubject.next(1);
      this.apiService.behaviorSubject.next('this is 2nd value');
      this.apiService.neBehSubject.next(2);
    }, 10000);
  }

  /* =========================================================
     INTERVIEW: debounce + switchMap = best for search
  ========================================================= */
  private setupTvMazeSearch() {
    fromEvent(this.showsInput.nativeElement, 'input')
      .pipe(
        debounceTime(500),
        switchMap((event: any) => {
          const query = event.target.value;
          return this.http.get(`https://api.tvmaze.com/search/shows?q=${query}`);
        }),
        takeUntil(this.destroy$)
      )
      .subscribe(res => console.log(res));
  }

  /* =========================================================
     INTERVIEW: Demonstrates map transformation
  ========================================================= */
  private setupArtInstituteSearch() {
    fromEvent(this.showsInputText.nativeElement, 'input')
      .subscribe((event: any) => {
        const q = event.target.value;
        this.http.get(`https://api.artic.edu/api/v1/artworks/search?q=${q}`)
          .pipe(
            tap(data => console.log('Before map', data)),
            map((res: any) => res.data),
            tap(data => console.log('After map', data))
          )
          .subscribe();
      });
  }

  /* =========================================================
     INTERVIEW: Raw fromEvent examples (comparison)
  ========================================================= */
  private basicFromEventExamples() {
    fromEvent(this.showsInput.nativeElement, 'input')
      .subscribe((event: any) => {
        const query = event.target.value;
        this.http.get(`https://api.tvmaze.com/search/shows?q=${query}`)
          .subscribe(res => console.log(res));
      });
  }

  /* =========================================================
     BASIC RXJS STREAM EXAMPLES
  ========================================================= */
  private basicRxjsExamples() {
    this.myObservable.subscribe(val => console.log(val));

    concat(of(1, 3), of(2, 4))
      .subscribe(res => console.log('concat:', res));

    this.doubled.subscribe(res => console.log('doubled:', res));
  }

  /* =========================================================
     INTERVIEW: interval + timer + takeUntil
  ========================================================= */
  private intervalExamples() {
    const source = interval(1000);
    const stop$ = timer(5000);

    source.pipe(takeUntil(stop$))
      .subscribe(val => console.log('interval:', val));
  }

  /* =========================================================
     INTERVIEW: combineLatest waits for all streams
  ========================================================= */
  private combineLatestExample() {
    const first = timer(1000, 1000);
    const second = interval(2000);
    const stop$ = timer(10000);

    combineLatest([first, second])
      .pipe(takeUntil(stop$))
      .subscribe(val => console.log('combineLatest:', val));
  }

  /* =========================================================
     INTERVIEW: mergeMap vs concatMap vs switchMap vs exhaustMap
  ========================================================= */
  loadWithMergeMap() {
    from([1,2,3]).pipe(
      mergeMap(id => this.service.getUser(id))
    ).subscribe();
  }

  loadWithconcatMap() {
    from([1,2,3]).pipe(
      concatMap(id => this.service.getUser(id))
    ).subscribe();
  }

  loadWithSwithMap() {
    from([1,2,3]).pipe(
      switchMap(id => this.service.getUser(id))
    ).subscribe();
  }

  loadWithexhaustMap() {
    from([1,2,3]).pipe(
      exhaustMap(id => this.service.getUser(id))
    ).subscribe();
  }

  /* =========================================================
     INTERVIEW: retry handles transient failures
  ========================================================= */
  retryWith() {
    ajax('https://api.example.com/data')
      .pipe(retry(1))
      .subscribe({
        error: () => console.error('Retry failed')
      });
  }

  /* =========================================================
     CLEANUP
  ========================================================= */
  ngOnDestroy(): void {
    this.destroy$.next();
    this.destroy$.complete();
  }
}
